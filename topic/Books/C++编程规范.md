---
title: C++编程规范
categories:
 - [ Books,C++编程规范]
date: 2023-03-01T14:06:42+08:00
draft: true
layout: draft
include_toc: true
url-root: C++编程规范
---

## tips
* 在获取多个锁时，通过安排所有获取同样的锁的代码以相同的顺序获取锁，可以避免死锁情况的发生。（释放锁则可以按照任意顺序进行。）解决方案之一，是按内存地址的升序获取锁，地址恰好提供了一个方便、唯一而且是应用程序范围的排序。
* Fun( shared_ptr<Widget>(new Widget), shared_ptr<Widget>(new Widget) );<br/>
这种代码是不安全的。C++标准给了编译器巨大的回旋余地，可以将构成函数两个参数的两个表达式重新排序。说得更具体一些，就是编译器可以交叉执行两个表达式：可能先执行两个对象的内存分配（通过调用operator new），然后再试图调用两个Widget构造函数。这恰恰为资源泄漏准备了温床，因为如果其中一个构造函数调用抛出异常的话，另一个对象的内存就永远也没有机会释放了！</br>
这种微妙的问题有一个简单的解决办法：遵循建议，绝对不要在一条语句中分配一个以上的资源，应该在自己的代码语句中执行显式的资源分配（比如 new），而且每次都应该马上将分配的资源赋予管理对象（比如shared_ptr）。
